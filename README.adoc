# R2DBC-DSL

This module provides `R2dbcRepository` for Web Querying throw REST API and Criteria building via `Dsl` class. Working with PostgreSQL, MySQL, Oracle, MS SQL. 

R2DBC-DSL contains the current version of the Spring Data R2dbc, and each commit to the master of Spring Data R2dbc repository is immediately published there under the new version into Maven Central.

The internal extension of the base repository `R2dbcRepository` in Spring Data R2dbc is due to the use of features by all methods, and not just those related to DSL. Also modified a lot of integration tests with DSL features.

The Maven Central dependency instead of the library `spring-data-r2dbc`:

[source,xml]
----
<dependency>
  <groupId>io.github.sevenparadigms</groupId>
  <artifactId>spring-data-r2dbc-dsl</artifactId>
  <version>3.5.3</version>
</dependency>
----

also common jar with Dsl model (it is convenient when using Reactive Feign Client):

[source,xml]
----
<dependency>
  <groupId>io.github.sevenparadigms</groupId>
  <artifactId>spring-data-r2dbc-dsl-common</artifactId>
  <version>3.5.3</version>
</dependency>
----

That library produce `R2dbcDslRepository` interface:
[source,kotlin]
----
interface R2dbcRepository<T, ID> : ReactiveCrudRepository<T, ID> {
    fun findOne(dsl: Dsl): Mono<T>
    fun findAll(dsl: Dsl): Flux<T>
    fun listener(): Flux<Notification>
    fun fullTextSearch(dsl: Dsl): Flux<T>
    fun saveBatch(models: Iterable<S>): Flux<Result>
}
----

and `Dsl` class:
[source,kotlin]
----
data class Dsl {
    val fields: Array<String>
    val query: String
    val lang: String
    val page: Int
    val size: Int
    val sort: String
}
----

## Features

1. Paging and Sorting full support with ordering in several columns at once

2. Dsl support all SQL predicates: `=, >, <, >=, <=, like, in, not in, is true, is false, is null, is not null`

3. Ability to choose resulted columns in `findAll(dsl: Dsl)` and `findOne(dsl: Dsl)` methods

4. Joins to any tables and build criteria on joined columns, also can select joined columns in result

5. Annotation `@Id` is not required in model, because column with name `id` in 99% of all tables has name `id`

6. Annotation `@Table` is not required in model, because table name in 99% of all tables equals model class name, the camel name automatic convert to sql underlined

7. JsonNode type in Java-model automatically converted to JSONB type of PostgreSQL database and back

8. Repository `listener` method can subscribe to listen of all changes of table from database in realtime over `Sink<Notification>`

9. Ranked full text search by field `tsv` as default with RUM index operator in `fullTextSearch` method

10. Utility class `FastMethodInvoker` is a modern reflection access to object properties, in performance comparable to direct access. 

## Concepts

The main idea is to reduce development time when all kinds of criteria can be formed at the frontend:

`localhost:8080/items?query=shops.type==mega,name~~biggest,price>=100 & fields=id,name & page=0 & size=20 & sort=itemType:asc,createdAt:desc`

then generated SQL:

`select id, name from items join shops on items.shop_id = shops.id where shops.type='mega' and name like '%biggest%' and price >= 100 order by item_type asc, created_at desc limit 20 offset 0`

#### Web query predicates (-> sql):

* "column##1 2 3" -> column in (1, 2, 3)
* "column!#1 2 3" -> column not in (1, 2, 3)
* "column==value" -> column = value
* "column!=value" -> column != value
* "column" -> column is true
* "!column" -> column is not true
* "@column" -> column is null
* "!@column" -> column is not null
* "column>>value" -> column > value
* "column>=value" -> column >= value
* "column<<value" -> column < value
* "column<=value" -> column <= value
* "column~~value" -> column like '%value%'
* "column@@value" -> column @@ '%value%'

#### Web query columns:

* column -> used as is
* column.type -> join table if column is not JsonNode type (model must contain columnId variable)
* column.header.title -> `column->'header'->>'title'` if column have JsonNode type

In `fields` property also can selected joined columns or jsonb path to output result.
For example column `type` of table `shops` or `title` of jsonb colunm can be choosed in resulted fields.

## Subscribe to async database UPDATE/INSERT events:

Before create universal notifier function:
[source,postgresql]
----
create function notify_sender() returns trigger
    language plpgsql
as
$$
BEGIN
    PERFORM pg_notify(
                    TG_TABLE_NAME,
                    json_build_object(
                            'operation', TG_OP,
                            'record', row_to_json(NEW)
                        )::text
                );
    RETURN NULL;
END;
$$;
----
and set to tables notifier by trigger:
[source,postgresql]
----
create trigger table_notify
    after insert or update
    on table
    for each row
execute procedure notify_sender();
----

and last in source code:
[source,kotlin]
----
dslRepository.listener()
          .onBackpressureLatest()
          .concatMap { notification ->
              val json = notification.parameter.toJsonNode()
              if (json["operation"].asText() == "INSERT") {
                  info("database event: $json")
              }            
          }          
----

## Ranked full text search:

Default language may be setting in: `spring.r2dbc.dsl.fts-lang`

or get if nothing from: `Locale.getCurrent()`

also can dynamically setting in Dsl class: `Dsl.create().lang('English')`

In table look field with name `tsv`, but can be setting in `Dsl.create().fts("ts_vector","web query text")`.
[source,postgresql]
----
CREATE TABLE public.jobject
(
    id         uuid                     DEFAULT uuid_generate_v1mc() NOT NULL,
    jtree      jsonb                    NOT NULL,
    jfolder_id uuid                     NOT NULL REFERENCES jfolder (id),
    created_at timestamp with time zone DEFAULT timezone('utc'::text, CURRENT_TIMESTAMP),
    tsv        tsvector,
    PRIMARY KEY (jfolder_id, id)
) PARTITION BY LIST (jfolder_id);

CREATE INDEX idx_jobject_tsv ON jobject USING rum (tsv rum_tsvector_ops);
----

and in source code:

[source,kotlin]
----
dslRepository.fullTextSearch(Dsl.create().fts("cool | pencil").pageable(0, 20))
----

## Batch insert:

Any type of object can be inserted from List because the operation is massive at high speed:

[source,kotlin]
----
dslRepository.saveBatch(listOf(cool1, cool2, pencil1, pencil2))
----

